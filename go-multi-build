#!/bin/bash

set -euo pipefail

# Default configuration
DEFAULT_PLATFORMS=( "linux/amd64" "darwin/amd64" "darwin/arm64" )
OUTPUT_DIR="."
PARALLEL=false
COMPRESS=false
DRY_RUN=false
CUSTOM_LDFLAGS='-extldflags "-static"'
CONFIG_FILE="go-multi-build.conf"
INCREMENTAL=false
EMBED_VERSION=false
VERBOSE=false
QUIET=false
CLEANUP=false
NO_COLOR=false
STRIP=false
CHECKSUMS=false
ARCHIVE=false
MANIFEST=false
VALIDATE=false
VALIDATE_STRICT=false
BINARY_NAME_PATTERN="{name}-{os}-{arch}"
SAVE_CONFIG=false

# Track which options were set via CLI (for --save-config)
CLI_PLATFORMS_SET=false
CLI_OUTPUT_DIR_SET=false
CLI_PARALLEL_SET=false
CLI_COMPRESS_SET=false
CLI_CUSTOM_LDFLAGS_SET=false
CLI_INCREMENTAL_SET=false
CLI_EMBED_VERSION_SET=false
CLI_STRIP_SET=false
CLI_CHECKSUMS_SET=false
CLI_ARCHIVE_SET=false
CLI_MANIFEST_SET=false
CLI_VALIDATE_SET=false
CLI_CLEANUP_SET=false
CLI_BINARY_NAME_PATTERN_SET=false

# Color codes (if colors are enabled)
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'
COLOR_RESET='\033[0m'

# Build summary tracking
declare -a BUILD_SUMMARY

# Help function
show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] <package-name>

Build Go projects for multiple platforms in a single run.

OPTIONS:
    -h, --help              Show this help message
    -p, --platforms LIST    Comma-separated list of platforms (e.g., "linux/amd64,darwin/arm64")
    -o, --output-dir DIR    Output directory for binaries (default: current directory)
    -P, --parallel          Build platforms in parallel
    -c, --compress          Compress binaries (requires upx)
    -d, --dry-run           Show what would be built without building
    -l, --ldflags FLAGS     Custom ldflags for go build (default: '-extldflags "-static"')
    -i, --incremental       Skip platforms that have already been built
    -v, --version           Embed version info from git (tag, commit, date)
    -V, --verbose           Verbose output (show all build details)
    -q, --quiet             Quiet mode (minimal output)
    -s, --strip             Strip debug symbols (adds -s -w to ldflags)
    --name-pattern PATTERN  Custom binary naming pattern (default: "{name}-{os}-{arch}")
                            Variables: {name}, {os}, {arch}, {version}, {commit}, {date}, {time}
    --checksums             Generate SHA256 checksums for binaries
    --archive               Create release archives (.tar.gz for Unix, .zip for Windows)
    --manifest              Generate build manifest file (JSON)
    --validate              Validate cross-compiled binaries (format, arch, size)
    --validate-strict       Fail build if validation errors occur
    --cleanup               Remove all previously built binaries before building
    --no-color              Disable colored output
    --save-config           Save command-line options to config file (interactive)

CONFIGURATION:
    Platforms can be configured via (in order of precedence):
    1. --platforms flag
    2. GO_BUILD_PLATFORMS environment variable
    3. go-multi-build.conf file (PLATFORMS="platform1,platform2,...")
    4. Default: linux/amd64, darwin/amd64, darwin/arm64

EXAMPLES:
    # Build with defaults
    $(basename "$0") myapp

    # Build for specific platforms
    $(basename "$0") --platforms "linux/amd64,windows/amd64" myapp

    # Build in parallel to custom directory
    $(basename "$0") -P -o build myapp

    # Dry run to see what would be built
    $(basename "$0") --dry-run myapp

See README for supported GOOS/GOARCH combinations.
EOF
    exit 0
}

# Parse command-line arguments
package=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -p|--platforms)
            IFS=',' read -ra PLATFORMS_ARG <<< "$2"
            CLI_PLATFORMS_SET=true
            shift 2
            ;;
        -o|--output-dir)
            OUTPUT_DIR="$2"
            CLI_OUTPUT_DIR_SET=true
            shift 2
            ;;
        -P|--parallel)
            PARALLEL=true
            CLI_PARALLEL_SET=true
            shift
            ;;
        -c|--compress)
            COMPRESS=true
            CLI_COMPRESS_SET=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -l|--ldflags)
            CUSTOM_LDFLAGS="$2"
            CLI_CUSTOM_LDFLAGS_SET=true
            shift 2
            ;;
        -i|--incremental)
            INCREMENTAL=true
            CLI_INCREMENTAL_SET=true
            shift
            ;;
        -v|--version)
            EMBED_VERSION=true
            CLI_EMBED_VERSION_SET=true
            shift
            ;;
        -V|--verbose)
            VERBOSE=true
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        --cleanup)
            CLEANUP=true
            CLI_CLEANUP_SET=true
            shift
            ;;
        --no-color)
            NO_COLOR=true
            shift
            ;;
        -s|--strip)
            STRIP=true
            CLI_STRIP_SET=true
            shift
            ;;
        --checksums)
            CHECKSUMS=true
            CLI_CHECKSUMS_SET=true
            shift
            ;;
        --archive)
            ARCHIVE=true
            CLI_ARCHIVE_SET=true
            shift
            ;;
        --manifest)
            MANIFEST=true
            CLI_MANIFEST_SET=true
            shift
            ;;
        --validate)
            VALIDATE=true
            CLI_VALIDATE_SET=true
            shift
            ;;
        --validate-strict)
            VALIDATE=true
            VALIDATE_STRICT=true
            CLI_VALIDATE_SET=true
            shift
            ;;
        --name-pattern|--binary-pattern)
            BINARY_NAME_PATTERN="$2"
            CLI_BINARY_NAME_PATTERN_SET=true
            shift 2
            ;;
        --save-config)
            SAVE_CONFIG=true
            shift
            ;;
        -*)
            echo "Error: Unknown option $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
        *)
            package="$1"
            shift
            ;;
    esac
done

# Disable colors if requested or not in a terminal
if [[ "$NO_COLOR" == true ]] || [[ ! -t 1 ]]; then
    COLOR_RED=''
    COLOR_GREEN=''
    COLOR_YELLOW=''
    COLOR_BLUE=''
    COLOR_CYAN=''
    COLOR_RESET=''
fi

# Logging functions
log_info() {
    [[ "$QUIET" == true ]] || echo -e "${COLOR_CYAN}$1${COLOR_RESET}"
}

log_success() {
    [[ "$QUIET" == true ]] || echo -e "${COLOR_GREEN}$1${COLOR_RESET}"
}

log_warning() {
    echo -e "${COLOR_YELLOW}$1${COLOR_RESET}" >&2
}

log_error() {
    echo -e "${COLOR_RED}$1${COLOR_RESET}" >&2
}

log_verbose() {
    [[ "$VERBOSE" == true ]] && echo -e "${COLOR_BLUE}[VERBOSE]${COLOR_RESET} $1"
}

# Validate Go installation
if ! command -v go &> /dev/null; then
    log_error "Error: Go is not installed or not in PATH"
    log_error "Please install Go from https://golang.org/dl/"
    exit 1
fi

log_verbose "Go version: $(go version)"

# Auto-detect package name from go.mod if not provided
if [[ -z "$package" ]]; then
    if [[ -f "go.mod" ]]; then
        package=$(grep '^module' go.mod | awk '{print $2}')
        if [[ -n "$package" ]]; then
            log_info "Auto-detected package from go.mod: $package"
        else
            log_error "Error: Could not auto-detect package name from go.mod"
            echo "Usage: $(basename "$0") [OPTIONS] <package-name>"
            echo "Use -h or --help for more information"
            exit 1
        fi
    else
        log_error "Error: package name required and no go.mod found"
        echo "Usage: $(basename "$0") [OPTIONS] <package-name>"
        echo "Use -h or --help for more information"
        exit 1
    fi
fi

# Validate that we're in a Go project directory
if [[ ! -f "go.mod" ]]; then
    log_warning "Warning: go.mod not found in current directory"
    log_warning "This might not be a Go module. Builds may fail."
fi

# Determine package name (extract last component from path)
package_name=$(basename "${package}")

# Validate name pattern
if ! validate_name_pattern "$BINARY_NAME_PATTERN"; then
    exit 1
fi

# Save configuration if requested
if [[ "$SAVE_CONFIG" == true ]]; then
    save_config
fi

# Extract version information from git if requested
if [[ "$EMBED_VERSION" == true ]]; then
    if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null 2>&1; then
        GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "dev")
        GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        VERSION_LDFLAGS="-X main.Version=${GIT_TAG} -X main.GitCommit=${GIT_COMMIT} -X main.BuildDate=${BUILD_DATE}"
        CUSTOM_LDFLAGS="${VERSION_LDFLAGS} ${CUSTOM_LDFLAGS}"
        log_info "Version info: ${GIT_TAG} (${GIT_COMMIT}) built on ${BUILD_DATE}"
    else
        log_warning "Warning: Git not available or not a git repository, skipping version embedding"
    fi
fi

# Add strip flags if requested
if [[ "$STRIP" == true ]]; then
    CUSTOM_LDFLAGS="-s -w ${CUSTOM_LDFLAGS}"
    log_verbose "Debug symbols will be stripped (-s -w)"
fi

# Load configuration from config file if it exists
if [[ -f "$CONFIG_FILE" ]]; then
    # Source config file
    source "$CONFIG_FILE"
fi

# Determine platforms (order of precedence: CLI > env var > config file > default)
if [[ -n "${PLATFORMS_ARG+x}" ]]; then
    platforms=("${PLATFORMS_ARG[@]}")
elif [[ -n "${GO_BUILD_PLATFORMS}" ]]; then
    IFS=',' read -ra platforms <<< "$GO_BUILD_PLATFORMS"
elif [[ -n "${PLATFORMS+x}" ]]; then
    # From config file
    IFS=',' read -ra platforms <<< "$PLATFORMS"
else
    platforms=("${DEFAULT_PLATFORMS[@]}")
fi

# Validate compress option
if [[ "$COMPRESS" == true ]] && ! command -v upx &> /dev/null; then
    log_warning "Warning: upx not found, compression will be skipped"
    COMPRESS=false
fi

# Create output directory if it doesn't exist
if [[ "$OUTPUT_DIR" != "." ]] && [[ "$DRY_RUN" == false ]]; then
    mkdir -p "$OUTPUT_DIR"
    log_verbose "Created output directory: $OUTPUT_DIR"
fi

# Cleanup old builds if requested
if [[ "$CLEANUP" == true ]]; then
    log_info "Cleaning up old builds..."
    for platform in "${platforms[@]}"; do
        platform_split=(${platform//\// })
        GOOS=${platform_split[0]}
        GOARCH=${platform_split[1]}
        binary_name=$(expand_binary_name "$BINARY_NAME_PATTERN" "$package_name" "$GOOS" "$GOARCH")
        output_name="${OUTPUT_DIR}/${binary_name}"
        if [[ -f "${output_name}" ]]; then
            rm -f "$output_name"
            log_verbose "Removed: $output_name"
        fi
        # Also remove related files (.sha256, .tar.gz, .zip)
        [[ -f "${output_name}.sha256" ]] && rm -f "${output_name}.sha256"
        [[ -f "${output_name}.tar.gz" ]] && rm -f "${output_name}.tar.gz"
        [[ -f "${output_name}.zip" ]] && rm -f "${output_name}.zip"
    done
    log_success "✓ Cleanup complete"
fi

# Show configuration in dry-run mode
if [[ "$DRY_RUN" == true ]]; then
    echo "=== Dry Run Mode ==="
    echo "Package: $package"
    echo "Package name: $package_name"
    echo "Output directory: $OUTPUT_DIR"
    echo "Binary name pattern: $BINARY_NAME_PATTERN"
    echo "Parallel: $PARALLEL"
    echo "Compress: $COMPRESS"
    echo "Custom ldflags: $CUSTOM_LDFLAGS"
    echo ""
    echo "Platforms to build:"
    for platform in "${platforms[@]}"; do
        platform_split=(${platform//\// })
        GOOS=${platform_split[0]}
        GOARCH=${platform_split[1]}
        binary_name=$(expand_binary_name "$BINARY_NAME_PATTERN" "$package_name" "$GOOS" "$GOARCH")
        output_name="${OUTPUT_DIR}/${binary_name}"
        echo "  - ${GOOS}/${GOARCH} -> ${output_name}"
    done
    exit 0
fi

# Format duration in human-readable format
format_duration() {
    local seconds=$1
    if (( seconds < 60 )); then
        printf "%.2fs" "$seconds"
    else
        printf "%dm %.2fs" $((seconds / 60)) $(echo "$seconds % 60" | bc)
    fi
}

# Expand binary name pattern with actual values
expand_binary_name() {
    local pattern="$1"
    local pkg_name="$2"
    local goos="$3"
    local goarch="$4"
    local result="$pattern"

    # Get version info if pattern uses these variables
    local version=""
    local commit=""
    local build_date=""
    local build_time=""

    if [[ "$pattern" =~ \{version\}|\{commit\}|\{date\}|\{time\} ]]; then
        if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null 2>&1; then
            version=$(git describe --tags --always 2>/dev/null || echo "dev")
            commit=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        else
            version="dev"
            commit="unknown"
        fi
        build_date=$(date -u +%Y%m%d)
        build_time=$(date -u +%H%M%S)
    fi

    # Replace all placeholders
    result="${result//\{name\}/$pkg_name}"
    result="${result//\{package\}/$pkg_name}"
    result="${result//\{os\}/$goos}"
    result="${result//\{goos\}/$goos}"
    result="${result//\{arch\}/$goarch}"
    result="${result//\{goarch\}/$goarch}"
    result="${result//\{version\}/$version}"
    result="${result//\{commit\}/$commit}"
    result="${result//\{date\}/$build_date}"
    result="${result//\{time\}/$build_time}"

    # Add .exe for Windows if not already present
    if [[ "$goos" == "windows" ]] && [[ ! "$result" =~ \.exe$ ]]; then
        result="${result}.exe"
    fi

    echo "$result"
}

# Validate name pattern
validate_name_pattern() {
    local pattern="$1"

    # Warn if pattern doesn't include {os} or {arch} (builds might overwrite each other)
    if [[ ! "$pattern" =~ \{os\}|\{goos\} ]] && [[ ! "$pattern" =~ \{arch\}|\{goarch\} ]]; then
        log_warning "Warning: Pattern doesn't include {os} or {arch} - builds may overwrite each other"
        log_warning "         Consider using different output directories per platform or include platform variables"
    fi

    # Check for invalid filename characters (common across platforms)
    if [[ "$pattern" =~ [\:\*\?\"\<\>\|] ]]; then
        log_error "Error: Pattern contains invalid filename characters: : * ? \" < > |"
        return 1
    fi

    return 0
}

# Save a single config option to file
save_config_option() {
    local config_file="$1"
    local key="$2"
    local value="$3"
    local is_boolean="${4:-false}"

    # Check if option already exists (commented or uncommented)
    local existing_line
    existing_line=$(grep -n "^${key}=" "$config_file" 2>/dev/null | head -1)
    local commented_line
    commented_line=$(grep -n "^#${key}=" "$config_file" 2>/dev/null | head -1)

    if [[ -n "$existing_line" ]] || [[ -n "$commented_line" ]]; then
        # Get current value
        local current_value
        if [[ -n "$existing_line" ]]; then
            current_value=$(echo "$existing_line" | cut -d= -f2- | sed 's/^[0-9]*://' | tr -d '"')
        else
            current_value="(commented out)"
        fi

        # Show current and new values
        echo ""
        log_warning "Option '${key}' already exists in ${config_file}"
        echo "  Current value: ${current_value}"
        echo "  New value:     ${value}"
        echo ""
        read -p "Overwrite with new value? (y/N): " -n 1 -r
        echo ""

        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            log_info "Skipping ${key} (keeping existing value)"
            return 0
        fi

        # Update existing line (uncomment if needed)
        if [[ "$OSTYPE" == "darwin"* ]]; then
            # macOS sed requires '' after -i
            sed -i '' "s|^${key}=.*|${key}=\"${value}\"|" "$config_file"
            sed -i '' "s|^#${key}=.*|${key}=\"${value}\"|" "$config_file"
        else
            sed -i "s|^${key}=.*|${key}=\"${value}\"|" "$config_file"
            sed -i "s|^#${key}=.*|${key}=\"${value}\"|" "$config_file"
        fi
        log_success "✓ Updated ${key} in ${config_file}"
    else
        # Add new option to config file
        echo "" >> "$config_file"
        echo "# Added by --save-config on $(date)" >> "$config_file"
        if [[ "$is_boolean" == "true" ]]; then
            echo "${key}=${value}" >> "$config_file"
        else
            echo "${key}=\"${value}\"" >> "$config_file"
        fi
        log_success "✓ Added ${key} to ${config_file}"
    fi
}

# Save CLI options to config file
save_config() {
    local config_file="$CONFIG_FILE"

    log_info "Saving command-line options to ${config_file}..."
    echo ""

    # Create config file if it doesn't exist
    if [[ ! -f "$config_file" ]]; then
        log_info "Creating new config file: ${config_file}"
        cat > "$config_file" << 'EOF'
# go-multi-build Configuration File
# Generated by go-multi-build --save-config
#
# Settings in this file can be overridden by:
#   - Environment variables (e.g., GO_BUILD_PLATFORMS)
#   - Command-line flags (e.g., --platforms)
#
# For more information, see: docs/configuration.md

EOF
    fi

    # Save each option that was set via CLI
    if [[ "$CLI_PLATFORMS_SET" == true ]]; then
        # Convert array to comma-separated string
        local platforms_str
        platforms_str=$(IFS=','; echo "${PLATFORMS_ARG[*]}")
        save_config_option "$config_file" "PLATFORMS" "$platforms_str"
    fi

    if [[ "$CLI_OUTPUT_DIR_SET" == true ]]; then
        save_config_option "$config_file" "OUTPUT_DIR" "$OUTPUT_DIR"
    fi

    if [[ "$CLI_PARALLEL_SET" == true ]]; then
        save_config_option "$config_file" "PARALLEL" "$PARALLEL" "true"
    fi

    if [[ "$CLI_COMPRESS_SET" == true ]]; then
        save_config_option "$config_file" "COMPRESS" "$COMPRESS" "true"
    fi

    if [[ "$CLI_CUSTOM_LDFLAGS_SET" == true ]]; then
        save_config_option "$config_file" "CUSTOM_LDFLAGS" "$CUSTOM_LDFLAGS"
    fi

    if [[ "$CLI_INCREMENTAL_SET" == true ]]; then
        save_config_option "$config_file" "INCREMENTAL" "$INCREMENTAL" "true"
    fi

    if [[ "$CLI_EMBED_VERSION_SET" == true ]]; then
        save_config_option "$config_file" "EMBED_VERSION" "$EMBED_VERSION" "true"
    fi

    if [[ "$CLI_STRIP_SET" == true ]]; then
        save_config_option "$config_file" "STRIP" "$STRIP" "true"
    fi

    if [[ "$CLI_CHECKSUMS_SET" == true ]]; then
        save_config_option "$config_file" "CHECKSUMS" "$CHECKSUMS" "true"
    fi

    if [[ "$CLI_ARCHIVE_SET" == true ]]; then
        save_config_option "$config_file" "ARCHIVE" "$ARCHIVE" "true"
    fi

    if [[ "$CLI_MANIFEST_SET" == true ]]; then
        save_config_option "$config_file" "MANIFEST" "$MANIFEST" "true"
    fi

    if [[ "$CLI_VALIDATE_SET" == true ]]; then
        save_config_option "$config_file" "VALIDATE" "$VALIDATE" "true"
        if [[ "$VALIDATE_STRICT" == true ]]; then
            save_config_option "$config_file" "VALIDATE_STRICT" "$VALIDATE_STRICT" "true"
        fi
    fi

    if [[ "$CLI_CLEANUP_SET" == true ]]; then
        save_config_option "$config_file" "CLEANUP" "$CLEANUP" "true"
    fi

    if [[ "$CLI_BINARY_NAME_PATTERN_SET" == true ]]; then
        save_config_option "$config_file" "BINARY_NAME_PATTERN" "$BINARY_NAME_PATTERN"
    fi

    echo ""
    log_success "✓ Configuration saved to ${config_file}"
    echo ""
}

# Validate binary function
validate_binary() {
    local binary_path=$1
    local expected_goos=$2
    local expected_goarch=$3
    local validation_results=""
    local has_errors=false

    log_verbose "Validating ${binary_path}..."

    # Check if file exists
    if [[ ! -f "${binary_path}" ]]; then
        log_error "  ✗ File not found: ${binary_path}"
        echo "format:fail,arch:fail,executable:fail,size:fail"
        return 1
    fi

    # Check file format and architecture using 'file' command
    local file_output=$(file "${binary_path}" 2>/dev/null)
    local format_valid=false
    local arch_valid=false

    # Validate based on expected platform
    case "${expected_goos}" in
        linux|freebsd|openbsd|netbsd)
            if echo "${file_output}" | grep -q "ELF"; then
                format_valid=true
                log_verbose "  ✓ Format: ELF (${expected_goos})"
            else
                log_warning "  ✗ Format: Expected ELF for ${expected_goos}, got: ${file_output}"
                has_errors=true
            fi
            ;;
        darwin)
            if echo "${file_output}" | grep -q "Mach-O"; then
                format_valid=true
                log_verbose "  ✓ Format: Mach-O (macOS)"
            else
                log_warning "  ✗ Format: Expected Mach-O for macOS, got: ${file_output}"
                has_errors=true
            fi
            ;;
        windows)
            if echo "${file_output}" | grep -qE "PE32|MS Windows"; then
                format_valid=true
                log_verbose "  ✓ Format: PE (Windows)"
            else
                log_warning "  ✗ Format: Expected PE for Windows, got: ${file_output}"
                has_errors=true
            fi
            ;;
        *)
            log_verbose "  ⊙ Format: Unknown OS ${expected_goos}, skipping format check"
            format_valid=true
            ;;
    esac

    # Validate architecture
    case "${expected_goarch}" in
        amd64)
            if echo "${file_output}" | grep -qE "x86-64|x86_64|AMD64"; then
                arch_valid=true
                log_verbose "  ✓ Architecture: x86-64"
            else
                log_warning "  ✗ Architecture: Expected x86-64, got: ${file_output}"
                has_errors=true
            fi
            ;;
        386)
            if echo "${file_output}" | grep -qE "i386|80386|x86"; then
                arch_valid=true
                log_verbose "  ✓ Architecture: i386"
            else
                log_warning "  ✗ Architecture: Expected i386, got: ${file_output}"
                has_errors=true
            fi
            ;;
        arm64)
            if echo "${file_output}" | grep -qE "arm64|aarch64|ARM aarch64"; then
                arch_valid=true
                log_verbose "  ✓ Architecture: ARM64"
            else
                log_warning "  ✗ Architecture: Expected ARM64, got: ${file_output}"
                has_errors=true
            fi
            ;;
        arm)
            if echo "${file_output}" | grep -qE "ARM|armv"; then
                arch_valid=true
                log_verbose "  ✓ Architecture: ARM"
            else
                log_warning "  ✗ Architecture: Expected ARM, got: ${file_output}"
                has_errors=true
            fi
            ;;
        *)
            log_verbose "  ⊙ Architecture: ${expected_goarch} (unable to verify)"
            arch_valid=true
            ;;
    esac

    # Check if executable
    local executable_valid=false
    if [[ -x "${binary_path}" ]]; then
        executable_valid=true
        log_verbose "  ✓ Executable: Yes"
    else
        log_warning "  ✗ Executable: No (missing +x permission)"
        has_errors=true
    fi

    # Size sanity check
    local file_size_bytes=$(stat -f%z "${binary_path}" 2>/dev/null || stat -c%s "${binary_path}" 2>/dev/null)
    local size_valid=true

    if [[ "${file_size_bytes}" -lt 10000 ]]; then
        log_warning "  ⚠ Size: Very small (${file_size_bytes} bytes) - possible incomplete build"
        size_valid=false
    elif [[ "${file_size_bytes}" -gt 500000000 ]]; then
        log_warning "  ⚠ Size: Very large (${file_size_bytes} bytes) - possible debug symbols"
        size_valid=false
    else
        log_verbose "  ✓ Size: $(du -h "${binary_path}" | cut -f1) (${file_size_bytes} bytes)"
    fi

    # Build validation result string
    validation_results="format:$(${format_valid} && echo 'pass' || echo 'fail')"
    validation_results="${validation_results},arch:$(${arch_valid} && echo 'pass' || echo 'fail')"
    validation_results="${validation_results},executable:$(${executable_valid} && echo 'pass' || echo 'fail')"
    validation_results="${validation_results},size:$(${size_valid} && echo 'pass' || echo 'warn')"

    # Summary
    if [[ "${has_errors}" == true ]]; then
        log_error "  ✗ Validation failed for ${binary_path}"
        echo "${validation_results}"
        return 1
    else
        log_success "  ✓ Validation passed for ${binary_path}"
        echo "${validation_results}"
        return 0
    fi
}

# Build function
build_platform() {
    local platform=$1
    platform_split=(${platform//\// })
    local GOOS=${platform_split[0]}
    local GOARCH=${platform_split[1]}

    # Expand the binary name pattern
    local binary_name
    binary_name=$(expand_binary_name "$BINARY_NAME_PATTERN" "$package_name" "$GOOS" "$GOARCH")

    # Handle directory creation if pattern includes subdirectories
    local binary_dir
    binary_dir=$(dirname "${OUTPUT_DIR}/${binary_name}")
    if [[ ! -d "$binary_dir" ]]; then
        mkdir -p "$binary_dir"
        log_verbose "Created directory: $binary_dir"
    fi

    local output_name="${OUTPUT_DIR}/${binary_name}"

    # Check if incremental build and binary already exists
    if [[ "${INCREMENTAL}" == true ]] && [[ -f "${output_name}" ]]; then
        local file_size=$(du -h "$output_name" | cut -f1)
        log_info "⊙ Skipped ${GOOS}/${GOARCH} (already exists, ${file_size})"
        BUILD_SUMMARY+=("SKIP|${GOOS}/${GOARCH}|${file_size}|0.00s|||not_validated")
        return 0
    fi

    local start_time=$(date +%s.%N)
    log_info "Building ${package} for ${GOOS}/${GOARCH}..."

    if [[ "$VERBOSE" == true ]]; then
        CGO_ENABLED=0 GOOS=${GOOS} GOARCH=${GOARCH} go build -a -ldflags "$CUSTOM_LDFLAGS" -o "${output_name}" .
        local build_result=$?
    else
        CGO_ENABLED=0 GOOS=${GOOS} GOARCH=${GOARCH} go build -a -ldflags "$CUSTOM_LDFLAGS" -o "${output_name}" . 2>&1 | grep -v "^#" || true
        local build_result=${PIPESTATUS[0]}
    fi

    if [[ "${build_result}" -ne 0 ]]; then
        log_error "Error: Build failed for ${GOOS}/${GOARCH}"
        BUILD_SUMMARY+=("FAIL|${GOOS}/${GOARCH}|N/A|N/A")
        return 1
    fi

    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)

    # Compress if requested
    if [[ "$COMPRESS" == true ]]; then
        log_verbose "Compressing ${output_name}..."
        upx -q "${output_name}" 2>/dev/null || log_warning "Warning: Compression failed for ${output_name}"
    fi

    # Get file size
    local file_size=$(du -h "$output_name" | cut -f1)
    local file_size_bytes=$(stat -f%z "$output_name" 2>/dev/null || stat -c%s "$output_name" 2>/dev/null)
    local formatted_duration=$(format_duration "$duration")

    # Validate binary if requested
    local validation_results="not_validated"
    if [[ "${VALIDATE}" == true ]]; then
        validation_results=$(validate_binary "$output_name" "$GOOS" "$GOARCH")
        local validation_status=$?

        if [[ "${validation_status}" -ne 0 ]] && [[ "${VALIDATE_STRICT}" == true ]]; then
            log_error "Build aborted due to validation failure (--validate-strict)"
            BUILD_SUMMARY+=("FAIL|${GOOS}/${GOARCH}|${file_size}|${formatted_duration}|${file_size_bytes}||${validation_results}")
            return 1
        fi
    fi

    # Generate checksum if requested
    local checksum=""
    if [[ "$CHECKSUMS" == true ]]; then
        log_verbose "Generating checksum for ${output_name}..."
        checksum=$(shasum -a 256 "$output_name" | cut -d' ' -f1)
        echo "$checksum  $(basename "$output_name")" > "${output_name}.sha256"
        log_verbose "Checksum: $checksum"
    fi

    # Create archive if requested
    if [[ "${ARCHIVE}" == true ]]; then
        log_verbose "Creating archive for ${output_name}..."
        local archive_name
        if [[ "${GOOS}" = "windows" ]]; then
            # Create .zip for Windows
            archive_name="${output_name}.zip"
            zip -q "$archive_name" "$(basename "$output_name")"
        else
            # Create .tar.gz for Unix
            archive_name="${output_name}.tar.gz"
            tar -czf "$archive_name" -C "$(dirname "$output_name")" "$(basename "$output_name")"
        fi
        log_verbose "Archive: $archive_name"
    fi

    log_success "✓ Built ${output_name} (${file_size}, ${formatted_duration})"
    BUILD_SUMMARY+=("OK|${GOOS}/${GOARCH}|${file_size}|${formatted_duration}|${file_size_bytes}|${checksum}|${validation_results}")
    return 0
}

# Build platforms
total_start_time=$(date +%s.%N)

if [[ "$PARALLEL" == true ]]; then
    echo "Building platforms in parallel..."
    pids=()
    failed=0

    for platform in "${platforms[@]}"; do
        build_platform "$platform" &
        pids+=($!)
    done

    # Wait for all background jobs
    for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
            failed=1
        fi
    done

    if [[ "${failed}" -ne 0 ]]; then
        echo ""
        echo "Error: One or more builds failed"
        exit 1
    fi
else
    # Sequential builds
    for platform in "${platforms[@]}"; do
        if ! build_platform "$platform"; then
            echo ""
            echo "Error: Build aborted due to failure"
            exit 1
        fi
    done
fi

total_end_time=$(date +%s.%N)
total_duration=$(echo "$total_end_time - $total_start_time" | bc)
formatted_total=$(format_duration "$total_duration")

echo ""
log_success "✓ All builds completed successfully in ${formatted_total}"

# Show build summary table
if [[ "$QUIET" == false ]] && [[ ${#BUILD_SUMMARY[@]} -gt 0 ]]; then
    echo ""
    echo "Build Summary:"
    echo "─────────────────────────────────────────────────"
    printf "%-6s %-20s %-10s %-10s\n" "Status" "Platform" "Size" "Time"
    echo "─────────────────────────────────────────────────"

    for entry in "${BUILD_SUMMARY[@]}"; do
        IFS='|' read -r status platform size time size_bytes checksum validation <<< "$entry"
        case $status in
            OK)
                printf "${COLOR_GREEN}%-6s${COLOR_RESET} %-20s %-10s %-10s\n" "✓" "$platform" "$size" "$time"
                ;;
            SKIP)
                printf "${COLOR_YELLOW}%-6s${COLOR_RESET} %-20s %-10s %-10s\n" "⊙" "$platform" "$size" "$time"
                ;;
            FAIL)
                printf "${COLOR_RED}%-6s${COLOR_RESET} %-20s %-10s %-10s\n" "✗" "$platform" "$size" "$time"
                ;;
        esac
    done

    echo "─────────────────────────────────────────────────"
    echo "Total time: ${formatted_total}"
fi

# Generate manifest file if requested
if [[ "$MANIFEST" == true ]]; then
    manifest_file="${OUTPUT_DIR}/build-manifest.json"
    log_info "Generating build manifest: ${manifest_file}"

    # Get git info if available
    local git_tag="unknown"
    local git_commit="unknown"
    if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null 2>&1; then
        git_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "untagged")
        git_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    fi

    # Start JSON
    cat > "$manifest_file" << EOF
{
  "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "build_time": "${formatted_total}",
  "package": "${package}",
  "package_name": "${package_name}",
  "git_tag": "${git_tag}",
  "git_commit": "${git_commit}",
  "output_dir": "${OUTPUT_DIR}",
  "builds": [
EOF

    # Add build entries
    local first=true
    for entry in "${BUILD_SUMMARY[@]}"; do
        IFS='|' read -r status platform size time size_bytes checksum validation <<< "$entry"

        if [[ "$first" == false ]]; then
            echo "    ," >> "$manifest_file"
        fi
        first=false

        platform_split=(${platform//\// })
        local goos=${platform_split[0]}
        local goarch=${platform_split[1]}
        local binary_name
        binary_name=$(expand_binary_name "$BINARY_NAME_PATTERN" "$package_name" "$goos" "$goarch")

        # Parse validation results if present
        local val_format="null"
        local val_arch="null"
        local val_exec="null"
        local val_size="null"

        if [[ "${validation}" != "not_validated" ]] && [[ -n "${validation}" ]]; then
            # Parse format:pass,arch:pass,executable:pass,size:warn
            val_format=$(echo "${validation}" | grep -oP 'format:\K[^,]+' || echo "null")
            val_arch=$(echo "${validation}" | grep -oP 'arch:\K[^,]+' || echo "null")
            val_exec=$(echo "${validation}" | grep -oP 'executable:\K[^,]+' || echo "null")
            val_size=$(echo "${validation}" | grep -oP 'size:\K[^,]+' || echo "null")
        fi

        cat >> "$manifest_file" << EOF
    {
      "platform": "${platform}",
      "goos": "${goos}",
      "goarch": "${goarch}",
      "status": "${status}",
      "binary": "${binary_name}",
      "size": "${size}",
      "size_bytes": ${size_bytes:-0},
      "build_time": "${time}",
      "sha256": "${checksum:-}",
      "validation": {
        "format": "${val_format}",
        "architecture": "${val_arch}",
        "executable": "${val_exec}",
        "size_check": "${val_size}"
      }
    }
EOF
    done

    # Close JSON
    cat >> "$manifest_file" << EOF

  ]
}
EOF

    log_success "✓ Manifest written to ${manifest_file}"
fi
