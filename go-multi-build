#!/bin/bash

set -euo pipefail

# Default configuration
DEFAULT_PLATFORMS=( "linux/amd64" "darwin/amd64" "darwin/arm64" )
OUTPUT_DIR="."
PARALLEL=false
COMPRESS=false
DRY_RUN=false
CUSTOM_LDFLAGS='-extldflags "-static"'
CONFIG_FILE="go-multi-build.conf"
INCREMENTAL=false
EMBED_VERSION=false
VERBOSE=false
QUIET=false
CLEANUP=false
NO_COLOR=false
STRIP=false
CHECKSUMS=false
ARCHIVE=false
MANIFEST=false

# Color codes (if colors are enabled)
COLOR_RED='\033[0;31m'
COLOR_GREEN='\033[0;32m'
COLOR_YELLOW='\033[0;33m'
COLOR_BLUE='\033[0;34m'
COLOR_CYAN='\033[0;36m'
COLOR_RESET='\033[0m'

# Build summary tracking
declare -a BUILD_SUMMARY

# Help function
show_help() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] <package-name>

Build Go projects for multiple platforms in a single run.

OPTIONS:
    -h, --help              Show this help message
    -p, --platforms LIST    Comma-separated list of platforms (e.g., "linux/amd64,darwin/arm64")
    -o, --output-dir DIR    Output directory for binaries (default: current directory)
    -P, --parallel          Build platforms in parallel
    -c, --compress          Compress binaries (requires upx)
    -d, --dry-run           Show what would be built without building
    -l, --ldflags FLAGS     Custom ldflags for go build (default: '-extldflags "-static"')
    -i, --incremental       Skip platforms that have already been built
    -v, --version           Embed version info from git (tag, commit, date)
    -V, --verbose           Verbose output (show all build details)
    -q, --quiet             Quiet mode (minimal output)
    -s, --strip             Strip debug symbols (adds -s -w to ldflags)
    --checksums             Generate SHA256 checksums for binaries
    --archive               Create release archives (.tar.gz for Unix, .zip for Windows)
    --manifest              Generate build manifest file (JSON)
    --cleanup               Remove all previously built binaries before building
    --no-color              Disable colored output

CONFIGURATION:
    Platforms can be configured via (in order of precedence):
    1. --platforms flag
    2. GO_BUILD_PLATFORMS environment variable
    3. go-multi-build.conf file (PLATFORMS="platform1,platform2,...")
    4. Default: linux/amd64, darwin/amd64, darwin/arm64

EXAMPLES:
    # Build with defaults
    $(basename "$0") myapp

    # Build for specific platforms
    $(basename "$0") --platforms "linux/amd64,windows/amd64" myapp

    # Build in parallel to custom directory
    $(basename "$0") -P -o build myapp

    # Dry run to see what would be built
    $(basename "$0") --dry-run myapp

See README for supported GOOS/GOARCH combinations.
EOF
    exit 0
}

# Parse command-line arguments
package=""
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            ;;
        -p|--platforms)
            IFS=',' read -ra PLATFORMS_ARG <<< "$2"
            shift 2
            ;;
        -o|--output-dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        -P|--parallel)
            PARALLEL=true
            shift
            ;;
        -c|--compress)
            COMPRESS=true
            shift
            ;;
        -d|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -l|--ldflags)
            CUSTOM_LDFLAGS="$2"
            shift 2
            ;;
        -i|--incremental)
            INCREMENTAL=true
            shift
            ;;
        -v|--version)
            EMBED_VERSION=true
            shift
            ;;
        -V|--verbose)
            VERBOSE=true
            shift
            ;;
        -q|--quiet)
            QUIET=true
            shift
            ;;
        --cleanup)
            CLEANUP=true
            shift
            ;;
        --no-color)
            NO_COLOR=true
            shift
            ;;
        -s|--strip)
            STRIP=true
            shift
            ;;
        --checksums)
            CHECKSUMS=true
            shift
            ;;
        --archive)
            ARCHIVE=true
            shift
            ;;
        --manifest)
            MANIFEST=true
            shift
            ;;
        -*)
            echo "Error: Unknown option $1"
            echo "Use -h or --help for usage information"
            exit 1
            ;;
        *)
            package="$1"
            shift
            ;;
    esac
done

# Disable colors if requested or not in a terminal
if [[ "$NO_COLOR" == true ]] || [[ ! -t 1 ]]; then
    COLOR_RED=''
    COLOR_GREEN=''
    COLOR_YELLOW=''
    COLOR_BLUE=''
    COLOR_CYAN=''
    COLOR_RESET=''
fi

# Logging functions
log_info() {
    [[ "$QUIET" == true ]] || echo -e "${COLOR_CYAN}$1${COLOR_RESET}"
}

log_success() {
    [[ "$QUIET" == true ]] || echo -e "${COLOR_GREEN}$1${COLOR_RESET}"
}

log_warning() {
    echo -e "${COLOR_YELLOW}$1${COLOR_RESET}" >&2
}

log_error() {
    echo -e "${COLOR_RED}$1${COLOR_RESET}" >&2
}

log_verbose() {
    [[ "$VERBOSE" == true ]] && echo -e "${COLOR_BLUE}[VERBOSE]${COLOR_RESET} $1"
}

# Validate Go installation
if ! command -v go &> /dev/null; then
    log_error "Error: Go is not installed or not in PATH"
    log_error "Please install Go from https://golang.org/dl/"
    exit 1
fi

log_verbose "Go version: $(go version)"

# Auto-detect package name from go.mod if not provided
if [[ -z "$package" ]]; then
    if [[ -f "go.mod" ]]; then
        package=$(grep '^module' go.mod | awk '{print $2}')
        if [[ -n "$package" ]]; then
            log_info "Auto-detected package from go.mod: $package"
        else
            log_error "Error: Could not auto-detect package name from go.mod"
            echo "Usage: $(basename "$0") [OPTIONS] <package-name>"
            echo "Use -h or --help for more information"
            exit 1
        fi
    else
        log_error "Error: package name required and no go.mod found"
        echo "Usage: $(basename "$0") [OPTIONS] <package-name>"
        echo "Use -h or --help for more information"
        exit 1
    fi
fi

# Validate that we're in a Go project directory
if [[ ! -f "go.mod" ]]; then
    log_warning "Warning: go.mod not found in current directory"
    log_warning "This might not be a Go module. Builds may fail."
fi

# Determine package name (extract last component from path)
package_name=$(basename "${package}")

# Extract version information from git if requested
if [[ "$EMBED_VERSION" == true ]]; then
    if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null 2>&1; then
        GIT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "dev")
        GIT_COMMIT=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        VERSION_LDFLAGS="-X main.Version=${GIT_TAG} -X main.GitCommit=${GIT_COMMIT} -X main.BuildDate=${BUILD_DATE}"
        CUSTOM_LDFLAGS="${VERSION_LDFLAGS} ${CUSTOM_LDFLAGS}"
        log_info "Version info: ${GIT_TAG} (${GIT_COMMIT}) built on ${BUILD_DATE}"
    else
        log_warning "Warning: Git not available or not a git repository, skipping version embedding"
    fi
fi

# Add strip flags if requested
if [[ "$STRIP" == true ]]; then
    CUSTOM_LDFLAGS="-s -w ${CUSTOM_LDFLAGS}"
    log_verbose "Debug symbols will be stripped (-s -w)"
fi

# Load configuration from config file if it exists
if [[ -f "$CONFIG_FILE" ]]; then
    # Source config file
    source "$CONFIG_FILE"
fi

# Determine platforms (order of precedence: CLI > env var > config file > default)
if [[ -n "${PLATFORMS_ARG+x}" ]]; then
    platforms=("${PLATFORMS_ARG[@]}")
elif [[ -n "${GO_BUILD_PLATFORMS}" ]]; then
    IFS=',' read -ra platforms <<< "$GO_BUILD_PLATFORMS"
elif [[ -n "${PLATFORMS+x}" ]]; then
    # From config file
    IFS=',' read -ra platforms <<< "$PLATFORMS"
else
    platforms=("${DEFAULT_PLATFORMS[@]}")
fi

# Validate compress option
if [[ "$COMPRESS" == true ]] && ! command -v upx &> /dev/null; then
    log_warning "Warning: upx not found, compression will be skipped"
    COMPRESS=false
fi

# Create output directory if it doesn't exist
if [[ "$OUTPUT_DIR" != "." ]] && [[ "$DRY_RUN" == false ]]; then
    mkdir -p "$OUTPUT_DIR"
    log_verbose "Created output directory: $OUTPUT_DIR"
fi

# Cleanup old builds if requested
if [[ "$CLEANUP" == true ]]; then
    log_info "Cleaning up old builds..."
    for platform in "${platforms[@]}"; do
        platform_split=(${platform//\// })
        GOOS=${platform_split[0]}
        GOARCH=${platform_split[1]}
        output_name="${OUTPUT_DIR}/${package_name}-${GOOS}-${GOARCH}"
        if [[ "${GOOS}" = "windows" ]]; then
            output_name+='.exe'
        fi
        if [[ -f "${output_name}" ]]; then
            rm -f "$output_name"
            log_verbose "Removed: $output_name"
        fi
    done
    log_success "✓ Cleanup complete"
fi

# Show configuration in dry-run mode
if [[ "$DRY_RUN" == true ]]; then
    echo "=== Dry Run Mode ==="
    echo "Package: $package"
    echo "Package name: $package_name"
    echo "Output directory: $OUTPUT_DIR"
    echo "Parallel: $PARALLEL"
    echo "Compress: $COMPRESS"
    echo "Custom ldflags: $CUSTOM_LDFLAGS"
    echo ""
    echo "Platforms to build:"
    for platform in "${platforms[@]}"; do
        platform_split=(${platform//\// })
        GOOS=${platform_split[0]}
        GOARCH=${platform_split[1]}
        output_name="${OUTPUT_DIR}/${package_name}-${GOOS}-${GOARCH}"
        if [[ "${GOOS}" = "windows" ]]; then
            output_name+='.exe'
        fi
        echo "  - ${GOOS}/${GOARCH} -> ${output_name}"
    done
    exit 0
fi

# Format duration in human-readable format
format_duration() {
    local seconds=$1
    if (( seconds < 60 )); then
        printf "%.2fs" "$seconds"
    else
        printf "%dm %.2fs" $((seconds / 60)) $(echo "$seconds % 60" | bc)
    fi
}

# Build function
build_platform() {
    local platform=$1
    platform_split=(${platform//\// })
    local GOOS=${platform_split[0]}
    local GOARCH=${platform_split[1]}

    local output_name="${OUTPUT_DIR}/${package_name}-${GOOS}-${GOARCH}"

    if [[ "${GOOS}" = "windows" ]]; then
        output_name+='.exe'
    fi

    # Check if incremental build and binary already exists
    if [[ "${INCREMENTAL}" == true ]] && [[ -f "${output_name}" ]]; then
        local file_size=$(du -h "$output_name" | cut -f1)
        log_info "⊙ Skipped ${GOOS}/${GOARCH} (already exists, ${file_size})"
        BUILD_SUMMARY+=("SKIP|${GOOS}/${GOARCH}|${file_size}|0.00s")
        return 0
    fi

    local start_time=$(date +%s.%N)
    log_info "Building ${package} for ${GOOS}/${GOARCH}..."

    if [[ "$VERBOSE" == true ]]; then
        CGO_ENABLED=0 GOOS=${GOOS} GOARCH=${GOARCH} go build -a -ldflags "$CUSTOM_LDFLAGS" -o "${output_name}" .
        local build_result=$?
    else
        CGO_ENABLED=0 GOOS=${GOOS} GOARCH=${GOARCH} go build -a -ldflags "$CUSTOM_LDFLAGS" -o "${output_name}" . 2>&1 | grep -v "^#" || true
        local build_result=${PIPESTATUS[0]}
    fi

    if [[ "${build_result}" -ne 0 ]]; then
        log_error "Error: Build failed for ${GOOS}/${GOARCH}"
        BUILD_SUMMARY+=("FAIL|${GOOS}/${GOARCH}|N/A|N/A")
        return 1
    fi

    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc)

    # Compress if requested
    if [[ "$COMPRESS" == true ]]; then
        log_verbose "Compressing ${output_name}..."
        upx -q "${output_name}" 2>/dev/null || log_warning "Warning: Compression failed for ${output_name}"
    fi

    # Get file size
    local file_size=$(du -h "$output_name" | cut -f1)
    local file_size_bytes=$(stat -f%z "$output_name" 2>/dev/null || stat -c%s "$output_name" 2>/dev/null)
    local formatted_duration=$(format_duration "$duration")

    # Generate checksum if requested
    local checksum=""
    if [[ "$CHECKSUMS" == true ]]; then
        log_verbose "Generating checksum for ${output_name}..."
        checksum=$(shasum -a 256 "$output_name" | cut -d' ' -f1)
        echo "$checksum  $(basename "$output_name")" > "${output_name}.sha256"
        log_verbose "Checksum: $checksum"
    fi

    # Create archive if requested
    if [[ "${ARCHIVE}" == true ]]; then
        log_verbose "Creating archive for ${output_name}..."
        local archive_name
        if [[ "${GOOS}" = "windows" ]]; then
            # Create .zip for Windows
            archive_name="${output_name}.zip"
            zip -q "$archive_name" "$(basename "$output_name")"
        else
            # Create .tar.gz for Unix
            archive_name="${output_name}.tar.gz"
            tar -czf "$archive_name" -C "$(dirname "$output_name")" "$(basename "$output_name")"
        fi
        log_verbose "Archive: $archive_name"
    fi

    log_success "✓ Built ${output_name} (${file_size}, ${formatted_duration})"
    BUILD_SUMMARY+=("OK|${GOOS}/${GOARCH}|${file_size}|${formatted_duration}|${file_size_bytes}|${checksum}")
    return 0
}

# Build platforms
total_start_time=$(date +%s.%N)

if [[ "$PARALLEL" == true ]]; then
    echo "Building platforms in parallel..."
    pids=()
    failed=0

    for platform in "${platforms[@]}"; do
        build_platform "$platform" &
        pids+=($!)
    done

    # Wait for all background jobs
    for pid in "${pids[@]}"; do
        if ! wait "$pid"; then
            failed=1
        fi
    done

    if [[ "${failed}" -ne 0 ]]; then
        echo ""
        echo "Error: One or more builds failed"
        exit 1
    fi
else
    # Sequential builds
    for platform in "${platforms[@]}"; do
        if ! build_platform "$platform"; then
            echo ""
            echo "Error: Build aborted due to failure"
            exit 1
        fi
    done
fi

total_end_time=$(date +%s.%N)
total_duration=$(echo "$total_end_time - $total_start_time" | bc)
formatted_total=$(format_duration "$total_duration")

echo ""
log_success "✓ All builds completed successfully in ${formatted_total}"

# Show build summary table
if [[ "$QUIET" == false ]] && [[ ${#BUILD_SUMMARY[@]} -gt 0 ]]; then
    echo ""
    echo "Build Summary:"
    echo "─────────────────────────────────────────────────"
    printf "%-6s %-20s %-10s %-10s\n" "Status" "Platform" "Size" "Time"
    echo "─────────────────────────────────────────────────"

    for entry in "${BUILD_SUMMARY[@]}"; do
        IFS='|' read -r status platform size time size_bytes checksum <<< "$entry"
        case $status in
            OK)
                printf "${COLOR_GREEN}%-6s${COLOR_RESET} %-20s %-10s %-10s\n" "✓" "$platform" "$size" "$time"
                ;;
            SKIP)
                printf "${COLOR_YELLOW}%-6s${COLOR_RESET} %-20s %-10s %-10s\n" "⊙" "$platform" "$size" "$time"
                ;;
            FAIL)
                printf "${COLOR_RED}%-6s${COLOR_RESET} %-20s %-10s %-10s\n" "✗" "$platform" "$size" "$time"
                ;;
        esac
    done

    echo "─────────────────────────────────────────────────"
    echo "Total time: ${formatted_total}"
fi

# Generate manifest file if requested
if [[ "$MANIFEST" == true ]]; then
    manifest_file="${OUTPUT_DIR}/build-manifest.json"
    log_info "Generating build manifest: ${manifest_file}"

    # Get git info if available
    local git_tag="unknown"
    local git_commit="unknown"
    if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null 2>&1; then
        git_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "untagged")
        git_commit=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
    fi

    # Start JSON
    cat > "$manifest_file" << EOF
{
  "build_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "build_time": "${formatted_total}",
  "package": "${package}",
  "package_name": "${package_name}",
  "git_tag": "${git_tag}",
  "git_commit": "${git_commit}",
  "output_dir": "${OUTPUT_DIR}",
  "builds": [
EOF

    # Add build entries
    local first=true
    for entry in "${BUILD_SUMMARY[@]}"; do
        IFS='|' read -r status platform size time size_bytes checksum <<< "$entry"

        if [[ "$first" == false ]]; then
            echo "    ," >> "$manifest_file"
        fi
        first=false

        platform_split=(${platform//\// })
        local goos=${platform_split[0]}
        local goarch=${platform_split[1]}
        local binary_name="${package_name}-${goos}-${goarch}"
        if [[ "${goos}" = "windows" ]]; then
            binary_name+='.exe'
        fi

        cat >> "$manifest_file" << EOF
    {
      "platform": "${platform}",
      "goos": "${goos}",
      "goarch": "${goarch}",
      "status": "${status}",
      "binary": "${binary_name}",
      "size": "${size}",
      "size_bytes": ${size_bytes:-0},
      "build_time": "${time}",
      "sha256": "${checksum:-}"
    }
EOF
    done

    # Close JSON
    cat >> "$manifest_file" << EOF

  ]
}
EOF

    log_success "✓ Manifest written to ${manifest_file}"
fi
